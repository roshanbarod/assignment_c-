28. How the Compiler Manages Polymorphism in C++
The compiler implements runtime polymorphism (dynamic binding) using vtables (virtual tables) and vptrs (virtual pointers). Here’s how it works:

1. Virtual Table (vtable)
A per-class table of function pointers generated by the compiler.

Contains addresses of all virtual functions defined in the class.

Created once per class (shared by all objects of that class).

2. Virtual Pointer (vptr)
A hidden pointer stored in every object of a polymorphic class.

Points to the vtable of its class.

Automatically initialized in the constructor.

3. Dynamic Dispatch
When a virtual function is called via a base pointer/reference, the compiler:

Follows the object’s vptr to its vtable.

Looks up the correct function address in the vtable.

Calls the derived class’s implementation (if overridden).

Example:
cpp
class Base {
public:
    virtual void foo() { cout << "Base"; }  // Stored in vtable
};

class Derived : public Base {
public:
    void foo() override { cout << "Derived"; }  // Overrides vtable entry
};

int main() {
    Base* b = new Derived();
    b->foo();  // Calls Derived::foo() via vtable lookup
    delete b;
}
Memory Layout:
Derived Object:
+-------------------+
| vptr (→ Derived's vtable) |
| Other data members |
+-------------------+

Derived's vtable:
+-------------------+
| &Derived::foo     |
+-------------------+